import {json} from "d3-fetch";
import {select} from "d3-selection";
import {range} from "d3-array";
import GroupedViolin from "./modules/GroupedViolin";

/**
 * Build the eQTL Dashboard
 * Initiate the dashboard with a search form.
 * 1. Fetch and organize tissue sites into groups.
 * 2. Build the two-level tissue site menu.
 * 3. Bind the search function to the submit button.
 * ToDo: perhaps the dom elements in the form could be accessed without specified dom IDs?
 * @param dashboardId {String}: eQTL result <div> ID
 * @param menuId {String} tissue menu <div> ID
 * @param pairId {String} gene-variant <textarea> ID
 * @param submitId {String} form submit button <div> ID
 * @param formId {String} dashboard <form> ID
 * @param messageBoxId {String} message box <div> ID
 * @param urls {Dictionary} of GTEx web service URLs
 */
export function build(dashboardId, menuId, pairId, submitId, formId, messageBoxId, urls=_getGTExUrls()){
    let tissueGroups = {}; // a dictionary of lists of tissue sites indexed by tissue groups
    try{
        json(urls.tissueSites)
        .then(function(data){ // retrieve all tissue (sub)sites
            // filter out invalide tissues due to sample size < 70
            const invalidTissues = ['Bladder', 'Cervix_Ectocervix', 'Cervix_Endocervix', 'Fallopian_Tube', 'Kidney_Cortex']; // temp solution: a hard-coded list because the sample size is not easy to retrieve
            let tissues = data.tissueSiteDetail.filter((d)=>{return !invalidTissues.includes(d.tissue_site_detail_id)}); // an array of tissue_site_detail objects

            // guild the tissueGroups lookup dictionary
            tissueGroups = tissues.reduce((arr, d)=>{
                const groupName = d.tissue_site;
                const site = {
                    id: d.tissue_site_detail_id,
                    name: d.tissue_site_detail
                };
                if (!arr.hasOwnProperty(groupName)) arr[groupName] = []; // initiate an array
                arr[groupName].push(site);
                return arr;
            }, {});

            // modification for the tissue groups with only a single site
            Object.keys(tissueGroups).forEach((d)=>{
                if (tissueGroups[d].length == 1){
                    // a single-site group
                    // replace the group's name with the single site's name, for a better alphabetical name order in the tissue menu
                    const site = tissueGroups[d][0]; // the single site
                    delete tissueGroups[d]; // remove the old group in the dictionary
                    tissueGroups[site.name] = [site]; // create a new group with the site's name
                }
            });
            _buildTissueMenu(tissueGroups, menuId);
            $(`#${submitId}`).click(_submit(tissueGroups, dashboardId, menuId, pairId, submitId, formId, messageBoxId, urls));
        });
    } catch (err){
        console.error(err);
    }

}

function _visualize(mainId, input, info){

    const id = {
        main: mainId,
        tooltip: "eqtlTooltip",
        toolbar: `${mainId}Toolbar`,
        clone: `${mainId}Clone`,
        chart: `${mainId}Chart`,
        svg: `${mainId}Svg`,
        buttons: {
            save: `${mainId}Save`
        }
    };

    // error-checking DOM elements
    if ($(`#${id.main}`).length == 0) throw "Violin Plot Error: the chart DOM doesn't exist";
    if ($(`#${id.tooltip}`).length == 0) $('<div/>').attr("id", id.tooltip).appendTo($('body'));

    // clear previously rendered plot if any
    select(`#${id.main}`).selectAll("*").remove();

    // build the dom elements
    ["toolbar", "chart", "clone"].forEach((d)=>{
        $('<div/>').attr("id", id[d]).appendTo($(`#${id.main}`));
    });

    // violin plot rendering

    let margin = {
        left: 50,
        top: 50,
        right: 50,
        bottom: 100
    };

    let innerWidth = input.length * 50,
        width = innerWidth + (margin.left + margin.right);
    let height = 200,
        innerHeight = height - (margin.top + margin.bottom);

    let dom = select(`#${id.chart}`)
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("id", id.svg)
        .append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

    let violin = new GroupedViolin(input, info);
    const tooltip = violin.createTooltip(id.tooltip);

    violin.render(dom, innerWidth, innerHeight, 0.3, undefined, [], "Rank Normalized Expression", false, true, 0, false, true, false);
    _customizeViolinPlot(violin, dom);
}
/**
 * Customization of the violin plot
 * @param plot {GroupedViolin}
 * @param dom {D3 DOM}
 */
function _customizeViolinPlot(plot, dom){
    plot.groups.forEach((g)=>{
        // customize the long tissue name
        const gname = g.key;
        const names = gname.split(" - ");
        const customXlabel = dom.append("g");
        const customLabels = customXlabel.selectAll(".violin-group-label")
            .data(names);
        customLabels.enter().append("text")
            .attr("x", 0)
            .attr("y", 0)
            .attr("class", "violin-group-label")
            .attr("transform", (d, i) => {
                let x = plot.scale.x(gname) + plot.scale.x.bandwidth()/2;
                let y = plot.scale.y(plot.scale.y.domain()[0]) + 55 + (10*i); // todo: avoid hard-coded values
                return `translate(${x}, ${y})`
            })
            .text((d) => d);
    });

    dom.selectAll(".violin-sub-axis").classed("violin-sub-axis-hide", true).classed("violin-sub-axis", false);

}

function _getGTExUrls(){
    const host = 'https://gtexportal.org/rest/v1/';
    return {
        gene: host + 'reference/geneId?format=json&release=v7&geneId=',
        rsId: host + 'reference/snp?reference=current&format=json&snpId=',
        variantId: host + 'reference/snp?format=json&reference=current&release=v7&variantId=',
        dyneqtl: 'https://gtexportal.org/rest/v1/association/dyneqtl',
        tissueSites: "https://gtexportal.org/rest/v1/dataset/tissueSiteDetail?format=json"
    }
}

/**
 * Build the two-level tissue menu
 * dependencies: eqtlDashboard.css classes
 * @param groups: a dictionary of list of tissues indexed by tissue groups
 * @param domId: the tissue menu <div> ID
 * @private
 * Dependencies: jQuery, Bootstrap, eqtlDashboard.css
 */
function _buildTissueMenu(groups, domId){
    const labelClass="ed-tissue-main-level";
    const labelSubClass = "ed-tissue-sub-level";
    const lastSiteClass = "last-site";

    // sort the tissue groups alphabetically
    let groupNames = Object.keys(groups).sort();

    // TODO: find a better way to organize tissues into DIV sections
    // create four <div> sections for the tissue menu
    const $sections = range(0,4).map((d)=>{
        return $(`<div id="section${d}" class="col-xs-12 col-md-3">`).appendTo($(`#${domId}`));
    });

    groupNames.forEach(function(gname){
        let sites = groups[gname]; // a list of site objects with attr: name and id
        const gId = gname.replace(/ /g, "_"); // replace the spaces with dashes to create a group <DOM> id

        // figure out which dom section to append this tissue site
        let $currentDom = $sections[3];
        if("Brain" == gname) $currentDom = $sections[0];
        else if (gname.match(/^[A-D]/)) $currentDom = $sections[1];
        else if (gname.match(/^[E-P]/)) $currentDom = $sections[2];

        // create the <label> for the tissue group
        $(`<label class=${labelClass}>`+
            `<input type="checkbox" id="${gId}" class="tissueGroup"> ` +
            '<span class="checkmark"></span>' +
            `<span>${gname}</span>` +
            '</label><br/>').appendTo($currentDom);

        // tissue sites in the group
        if (sites.length > 1){
             // sort sites alphabetically
            sites.sort((a, b)=>{
                if (a.id > b.id) return 1;
                if (a.id < b.id) return -1;
                return 0;
            })
            .forEach(function(site, i){
                let $siteDom = $(`<label class=${labelSubClass}>`+
                                `<input type="checkbox" id="${site.id}"> ` +
                                '<span class="checkmark"></span>' +
                                `<span>${site.name}</span>` +
                                '</label><br/>').appendTo($currentDom);
                if (i == sites.length -1) $siteDom.addClass(lastSiteClass);
            });
        }


        // custom click event for the top-level tissues: toggle the check boxes
        $("#" + gId).click(function(){
            if ($('#' + gId).is(":checked")) {
                // when the group is checked, check all its tissues
                sites.forEach(function (site) {
                    if ("id" == site.id) return;
                    $('#' + site.id).attr('checked', true);
                });
            }
            else {
                // when the group is unchecked, un-check all its tissues
                sites.forEach(function (site) {
                    if ("id" == site.id) return;
                    $('#' + site.id).attr('checked', false);
                });
            }
        });
    });

}

/**
 * Define the submit button's action
 * @param tissueGroups {Dictionary} of lists of tissues indexed by tissue groups
 * @param dashboardId {String} eQTL results <div> ID
 * @param menuId {String} tissue menu <div> ID
 * @param pairId {String} gene-variant <textarea> ID
 * @param submitId {String} submit button <div> ID
 * @param messageBoxId {String} message box <div> ID
 * @param urls {Dictionary} of GTEx web service URLs
 * @param max {Integer} max number of gene-variant entries. The default is set to 30.
 * @private
 * Dependencies: jQuery
 */
function _submit(tissueGroups, dashboardId, menuId, pairId, submitId, formId, messageBoxId, urls=_getGTExUrls(), max=30){
    return function(){

        // clear the previous dashboard search results if any
        $(`#${dashboardId}`).html('');

        ////// validate tissue inputs and convert them to tissue IDs //////
        let queryTissueIds = [];
        $(`#${menuId}`).find(":input").each(function(){ // using jQuery to parse each input item
            if ( $(this).is(":checked")) { // the jQuery way to fetch a checked tissue
                const id = $(this).attr('id');
                if ($(this).hasClass("tissueGroup")){
                    // this input item is a tissue group
                    // check if this tissue group is a single-site group using the tissueGroups dictionary
                    // if so, add the single site to the query list
                    let groupName = id.replace(/_/g, " "); // first convert the ID back to group name
                    if (tissueGroups[groupName].length == 1) {
                        queryTissueIds.push(tissueGroups[groupName][0].id);
                    }
                }
                else{ // this input item is a tissue site
                    queryTissueIds.push(id);
                }
            }
        });

        // tissue input error-checking
        if (queryTissueIds.length == 0) {
            alert("Must select at least one tissue.");
            throw "Input error";
        }

        ////// parse the gene-variant input list //////
        let pairs = $(`#${pairId}`).val().split("\n").filter(function(d){return d != ""});
        if (pairs.length == 0) {
            alert("Must input at least one gene-variant pair.");
            throw "Input error";
        }
        else if (pairs.length > max) {
            $(`#${messageBoxId}`).append(`Your input has exceeded the maximum number of allowed entries. Only the first ${max} entries are processed.`);
            console.warn("User input has exceeded the maximum number of allowed entries.");
            pairs = pairs.slice(0, max);
        }

        ////// process each gene-variant pair //////

        // create a tissue name lookup table
        const tissueDict = {};
        Object.keys(tissueGroups).forEach((gname) => {
            tissueGroups[gname].forEach((site) => {
                tissueDict[site.id] = site.name;
            });
        });

        // for each gene-variant pair
        pairs.forEach(function(pair, i){
            pair.replace(/ /g, ""); // remove all spaces
            let vid = pair.split(',')[1],
                gid = pair.split(',')[0];

            // retrieve gene and variant info from the web service
            const geneUrl = urls.gene + gid;
            const variantUrl = vid.toLowerCase().startsWith('rs')?urls.rsId+vid:urls.variantId+vid;
            const promises = [];

            Promise.all([json(geneUrl), json(variantUrl)])
                .then(function(args){
                    const gene = _parseGene(args[0], gid);
                    const variant = _parseVariant(args[1]);
                    if (gene === null){
                        const errorMessage = `Input Error: no gene found for ${gid}. <br/>`;
                        $(`#${messageBoxId}`).append(errorMessage);
                        throw errorMessage;
                    }
                    if (variant === null){
                        const errorMessage = `Input Error: no variant found for ${vid} <br/>`;
                        $(`#${messageBoxId}`).append(errorMessage);
                        throw errorMessage;
                    }

                    // calculate eQTLs and display the eQTL violin plots
                    _renderEqtlPlot(tissueDict, dashboardId, gene, variant, queryTissueIds, i);

                    // hide the search form after the eQTL violin plots are reported
                    $(`#${formId}`).removeClass("show"); // for bootstrap 4
                    $(`#${formId}`).removeClass("in"); // for boostrap 3
                    }
                )
                .catch(function(err){
                    console.error(err);
                });
        });
    };
}

/**
 * Parse GTEx gene web service
 * @param gjson
 * @param id {String} the query gene ID
 * @returns {*} a gene object or null if not found
 * @private
 */
function _parseGene(gjson, id){
    const attr = 'geneId';
    if(!gjson.hasOwnProperty(attr)) throw 'Fatal Error: parse gene error';
    let genes = gjson[attr].filter((d) => {return d.geneSymbolUpper == id.toUpperCase() || d.gencodeId == id.toUpperCase()}); // find the exact match
    if (genes.length ==0) return null;
    return genes[0];
}

/**
 * Parse GTEx variant/snp web service
 * @param vjson
 * @returns {*} a variant object or null
 * @private
 */
function _parseVariant(vjson){
    const attr = 'snp';
    if(!vjson.hasOwnProperty(attr)) throw 'Fatal Error: parse variant error';
    const variants = vjson[attr];
    if (variants.length == 0) return null;
    return variants[0];
}

/**
 * calculate the eQTLs and fetch expression of genotypes for each gene-variant pair
 * @param tissuDict {Dictionary} tissue name lookup table, indexed by tissue IDs
 * @param dashboardId {String} the dashboard results <div> ID
 * @param gene {Object} a GTEx gene object
 * @param variant {Object} the GTEx variant object
 * @param tissues {List} of query tissue IDs
 * @param i {Integer} the boxplot DIV's index
 * @private
 */
function _renderEqtlPlot(tissueDict, dashboardId, gene, variant, tissues, i) {
    // display gene-variant pair names
    const id = `boxplot${i}`;
    $(`#${dashboardId}`).append(`<h5>${gene.geneSymbol} <small>(${gene.gencodeId})</small> and ${variant.snpId||""} <small>(${variant.variantId})</small></h5>`); // TODO: display this as <text> in the SVG?
    $(`#${dashboardId}`).append(`<div id="${id}" class="col-sm-12"></div>`);

    // d3-queue https://github.com/d3/d3-queue
    let promises = [];

    // queue up all tissue IDs
    tissues.forEach((tId) => {
        let urlRoot = _getGTExUrls()['dyneqtl'];
        let url = `${urlRoot}?snp_id=${variant.variantId}&gene_id=${gene.gencodeId}&tissue=${tId}`; // use variant ID, gencode ID and tissue ID to query the dyneqtl
        promises.push(_apiCall(url, tId));
    });

    Promise.all(promises)
        .then(function(results){
            let input = []; // a list of genotype expression objects
            let info = {};
            results.forEach((d) => {
                if (d.status == "failed"){
                // if eQTLs aren't available for this query, create an empty space for the layout of the report
                let group = tissueDict[d.tissue]; // group refers to the tissue name, map tissue ID to tissue name
                // genotype expression data
                input = input.concat([
                    {
                        group: group,
                        label: "Ref",
                        values: [0]
                    },
                    {
                        group: group,
                        label: "Het",
                        values: [0]
                    },
                    {
                        group: group,
                        label: "Alt",
                        values: [0]
                    }
                ])
            }
                else {
                d = _parseEqtl(d); // reformat eQTL results d
                let group = tissueDict[d.tissue]; // group is the tissue name, map tissue ID to tissue name

                input = input.concat([
                    {
                        group: group,
                        label: `Ref (${d.homoRefExp.length})`,
                        values: d.homoRefExp
                    },
                    {
                        group: group,
                        label: `Het (${d.heteroExp.length})`,
                        values: d.heteroExp
                    },
                    {
                        group: group,
                        label: `Alt (${d.homoAltExp.length})`,
                        values: d.homoAltExp
                    }
                ]);
                // additional info of the group goes here
                info[group] = {
                    "pvalue": d["p-value"]===null?1:parseFloat(d["p-value"]).toPrecision(3),
                    "pvalueThreshold": d["p-value_threshold"]===null?0:parseFloat(d["p-value_threshold"]).toPrecision(3)
                }
            }

            });
            _visualize(id, input, info);
        })
        .catch(function(err){console.error(err)});
}

/**
 * parse GTEx dyneqtl json
 * @param data {JSON} from GTEx dyneqtl web service
 * @returns data {JSON} modified data
 * @private
 */
function _parseEqtl(data){
    data.expression_values = data.expression_values.split(",").map((d)=>parseFloat(d));
    data.genotypes = data.genotypes.split(",").map((d)=>parseFloat(d));

    data.homoRefExp = data.expression_values.filter((d,i) => {
        return data.genotypes[i] == 0
    });
    data.homoAltExp = data.expression_values.filter((d,i) => {
        return data.genotypes[i] == 2
    });
    data.heteroExp = data.expression_values.filter((d,i) => {
        return data.genotypes[i] == 1
    });
    return data;
}

function _apiCall(url, tissue){
    // reference: http://adampaxton.com/handling-multiple-javascript-promises-even-if-some-fail/
    return new Promise(function(resolve, reject){
        json(url)
            .then(function(request) {
                resolve(request);
            })
            .catch(function(err){
                // report the tissue as failed
                const failed = {
                    tissue: tissue,
                    status: "failed"
                };
                resolve(failed);
            });
        })

}




